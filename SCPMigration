#!/usr/bin/env python3
"""
RunPod File Transfer Tool v2.1
A CLI utility for transferring files between RunPod instances using SCP.
Author: Assistant
Last Updated: 2025-08-12
"""

import os
import sys
import subprocess
import re
from pathlib import Path

# Script version
VERSION = "1.0.5"
SCRIPT_NAME = "RunPod File Transfer Tool"

class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    WARNING = '\033[91m'  # Changed from yellow to red for better visibility
    YELLOW = '\033[91m'   # Changed from yellow to red for better visibility
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'

def print_header(text):
    print(f"\n{Colors.HEADER}{'='*50}{Colors.ENDC}")
    print(f"{Colors.HEADER}{text.center(50)}{Colors.ENDC}")
    print(f"{Colors.HEADER}{'='*50}{Colors.ENDC}")

def print_success(text):
    print(f"{Colors.GREEN}âœ“ {text}{Colors.ENDC}")

def print_error(text):
    print(f"{Colors.FAIL}âœ— {text}{Colors.ENDC}")

def print_warning(text):
    print(f"{Colors.WARNING}âš  {text}{Colors.ENDC}")

def print_info(text):
    print(f"{Colors.CYAN}â„¹ {text}{Colors.ENDC}")

def check_ssh_installed():
    """Check if SSH client is installed"""
    try:
        subprocess.run(['ssh', '-V'], capture_output=True, check=True)
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False

def check_scp_installed():
    """Check if SCP is installed"""
    try:
        subprocess.run(['scp'], capture_output=True)
        return True
    except FileNotFoundError:
        return False

def install_ssh():
    """Install SSH client"""
    print_info("Installing SSH client...")
    try:
        # Try to install openssh-client
        subprocess.run(['apt', 'update'], check=True, capture_output=True)
        subprocess.run(['apt', 'install', '-y', 'openssh-client'], check=True, capture_output=True)
        print_success("SSH client installed successfully!")
        return True
    except subprocess.CalledProcessError:
        print_error("Failed to install SSH client. Please install manually.")
        return False

def parse_ssh_command(ssh_command):
    """Parse SSH command to extract host, port, and user"""
    # Pattern: ssh user@host -p port
    pattern = r'ssh\s+(\w+)@([\d\.]+)\s+-p\s+(\d+)'
    match = re.match(pattern, ssh_command.strip())
    
    if match:
        user, host, port = match.groups()
        return user, host, port
    else:
        print_error("Invalid SSH command format. Expected: ssh user@host -p port")
        return None, None, None

def list_files_and_folders(path="."):
    """List files and folders in the given path"""
    try:
        items = []
        path_obj = Path(path).resolve()
        
        # Add parent directory option if not at root
        if path_obj != path_obj.parent:
            items.append(("../", "ðŸ“ Parent Directory", True))
        
        # List directories first, then files
        for item in sorted(path_obj.iterdir(), key=lambda x: (x.is_file(), x.name.lower())):
            if item.is_dir():
                items.append((str(item), f"ðŸ“ {item.name}/", True))
            else:
                size = item.stat().st_size
                size_str = format_file_size(size)
                items.append((str(item), f"ðŸ“„ {item.name} ({size_str})", False))
        
        return items, str(path_obj)
    except PermissionError:
        print_error(f"Permission denied accessing {path}")
        return [], path
    except Exception as e:
        print_error(f"Error listing directory: {e}")
        return [], path

def format_file_size(size_bytes):
    """Format file size in human readable format"""
    if size_bytes == 0:
        return "0 B"
    
    units = ['B', 'KB', 'MB', 'GB', 'TB']
    unit_index = 0
    size = float(size_bytes)
    
    while size >= 1024 and unit_index < len(units) - 1:
        size /= 1024
        unit_index += 1
    
    if unit_index == 0:
        return f"{int(size)} {units[unit_index]}"
    else:
        return f"{size:.1f} {units[unit_index]}"

def select_file_or_folder():
    """Interactive file/folder selection with separate navigation and selection modes"""
    current_path = "/workspace" if os.path.exists("/workspace") else os.getcwd()
    
    while True:
        # NAVIGATION MODE
        while True:
            print_header("NAVIGATION MODE - Browse Files")
            items, current_path = list_files_and_folders(current_path)
            
            if not items:
                print_error("No items found in current directory")
                return None
            
            print(f"\n{Colors.BOLD}Current directory: {current_path}{Colors.ENDC}")
            print(f"\n{Colors.CYAN}Navigate by entering a number:{Colors.ENDC}")
            
            # Show items for navigation only
            for i, (path, display_name, is_dir) in enumerate(items, 1):
                if path == "../":
                    print(f"{Colors.BLUE}{i:2d}.{Colors.ENDC} {display_name}")
                elif is_dir:
                    print(f"{Colors.BLUE}{i:2d}.{Colors.ENDC} {display_name}")
                else:
                    print(f"{Colors.BLUE}{i:2d}.{Colors.ENDC} {display_name}")
            
            print(f"\n{Colors.GREEN}Ready to transfer something?{Colors.ENDC}")
            print(f"  {Colors.BOLD}s{Colors.ENDC} - Switch to SELECTION MODE")
            print(f"\n{Colors.WARNING}Other commands:{Colors.ENDC}")
            print(f"  {Colors.BOLD}h{Colors.ENDC} - Go to /workspace")
            print(f"  {Colors.BOLD}r{Colors.ENDC} - Go to root /")
            print(f"  {Colors.BOLD}q{Colors.ENDC} - Quit")
            
            try:
                choice = input(f"\n{Colors.BOLD}Navigate to (number/s/h/r/q): {Colors.ENDC}").strip().lower()
                
                if choice == 'q':
                    return None
                elif choice == 's':
                    break  # Exit navigation mode, enter selection mode
                elif choice == 'h':
                    current_path = "/workspace" if os.path.exists("/workspace") else os.path.expanduser("~")
                    continue
                elif choice == 'r':
                    current_path = "/"
                    continue
                
                # Try to parse as number for navigation
                try:
                    choice_idx = int(choice) - 1
                    if 0 <= choice_idx < len(items):
                        selected_path, display_name, is_dir = items[choice_idx]
                        
                        if selected_path == "../":
                            # Navigate to parent directory
                            current_path = str(Path(current_path).parent)
                            continue
                        elif is_dir:
                            # Navigate into directory
                            current_path = selected_path
                            continue
                        else:
                            # It's a file, suggest selection mode
                            print(f"\n{Colors.YELLOW}That's a file! Switch to selection mode (s) to transfer files.{Colors.ENDC}")
                            input("Press Enter to continue...")
                            continue
                    else:
                        print_error("Invalid choice. Please try again.")
                except ValueError:
                    print_error("Please enter a valid number or command (s/h/r/q).")
                    
            except KeyboardInterrupt:
                print("\n\nTransfer cancelled by user.")
                return None
        
        # SELECTION MODE
        while True:
            print_header("SELECTION MODE - Choose Files to Transfer")
            items, current_path = list_files_and_folders(current_path)
            
            if not items:
                print_error("No items found in current directory")
                return None
            
            print(f"\n{Colors.BOLD}Current directory: {current_path}{Colors.ENDC}")
            print(f"\n{Colors.GREEN}Select a file or folder to transfer:{Colors.ENDC}")
            
            # Show items for selection
            for i, (path, display_name, is_dir) in enumerate(items, 1):
                if path == "../":
                    print(f"{Colors.BLUE}{i:2d}.{Colors.ENDC} {display_name} {Colors.CYAN}[Navigate up]{Colors.ENDC}")
                elif is_dir:
                    print(f"{Colors.BLUE}{i:2d}.{Colors.ENDC} {display_name} {Colors.GREEN}[Select entire folder]{Colors.ENDC}")
                else:
                    print(f"{Colors.BLUE}{i:2d}.{Colors.ENDC} {display_name} {Colors.GREEN}[Select file]{Colors.ENDC}")
            
            print(f"\n{Colors.WARNING}Commands:{Colors.ENDC}")
            print(f"  {Colors.BOLD}n{Colors.ENDC} - Switch back to NAVIGATION MODE")
            print(f"  {Colors.BOLD}h{Colors.ENDC} - Go to /workspace")
            print(f"  {Colors.BOLD}r{Colors.ENDC} - Go to root /")
            print(f"  {Colors.BOLD}q{Colors.ENDC} - Quit")
            
            try:
                choice = input(f"\n{Colors.BOLD}Select item (number/n/h/r/q): {Colors.ENDC}").strip().lower()
                
                if choice == 'q':
                    return None
                elif choice == 'n':
                    break  # Exit selection mode, go back to navigation mode
                elif choice == 'h':
                    current_path = "/workspace" if os.path.exists("/workspace") else os.path.expanduser("~")
                    continue
                elif choice == 'r':
                    current_path = "/"
                    continue
                
                # Try to parse as number for selection
                try:
                    choice_idx = int(choice) - 1
                    if 0 <= choice_idx < len(items):
                        selected_path, display_name, is_dir = items[choice_idx]
                        
                        if selected_path == "../":
                            # Navigate to parent directory
                            current_path = str(Path(current_path).parent)
                            continue
                        else:
                            # File or folder selected for transfer - confirm
                            item_type = "folder" if is_dir else "file"
                            item_name = display_name.replace('ðŸ“ ', '').replace('ðŸ“„ ', '').split(' (')[0]
                            
                            print(f"\n{Colors.GREEN}Selected {item_type}: {Colors.BOLD}{item_name}{Colors.ENDC}")
                            print(f"Path: {selected_path}")
                            
                            confirm = input(f"\n{Colors.YELLOW}Transfer this {item_type}? (y/N): {Colors.ENDC}").strip().lower()
                            if confirm == 'y':
                                return selected_path
                            else:
                                print_info("Selection cancelled, continuing...")
                                continue
                    else:
                        print_error("Invalid choice. Please try again.")
                except ValueError:
                    print_error("Please enter a valid number or command (n/h/r/q).")
                    
            except KeyboardInterrupt:
                print("\n\nTransfer cancelled by user.")
                return None

def get_connection_details():
    """Get SSH connection details from user"""
    print_header("SSH CONNECTION DETAILS")
    
    print(f"{Colors.CYAN}Please provide the SSH connection details for the destination pod:{Colors.ENDC}")
    
    while True:
        ssh_command = input(f"\n{Colors.BOLD}Enter SSH command (e.g., ssh root@213.173.111.95 -p 17958): {Colors.ENDC}").strip()
        
        user, host, port = parse_ssh_command(ssh_command)
        if user and host and port:
            break
        print_error("Please enter a valid SSH command.")
    
    password = input(f"{Colors.BOLD}Enter password: {Colors.ENDC}").strip()
    
    return user, host, port, password

def test_ssh_connection(user, host, port, password):
    """Test SSH connection"""
    print_info("Testing SSH connection...")
    
    try:
        # Use sshpass if available, otherwise prompt user
        cmd = ['sshpass', '-p', password, 'ssh', '-o', 'StrictHostKeyChecking=no', 
               '-o', 'ConnectTimeout=10', f'{user}@{host}', '-p', port, 'echo "Connection successful"']
        
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=15)
        
        if result.returncode == 0:
            print_success("SSH connection test successful!")
            return True
        else:
            print_error(f"SSH connection failed: {result.stderr}")
            return False
            
    except FileNotFoundError:
        print_warning("sshpass not found. Please ensure you can connect manually.")
        return True  # Assume it will work
    except subprocess.TimeoutExpired:
        print_error("SSH connection timed out.")
        return False
    except Exception as e:
        print_error(f"Error testing connection: {e}")
        return False

def perform_transfer(source_path, user, host, port, password):
    """Perform the file transfer using SCP with compression options"""
    print_header("FILE TRANSFER")
    
    source_path_obj = Path(source_path)
    is_directory = source_path_obj.is_dir()
    
    # Automatic transfer method selection
    compress = False
    compress_format = "zip"
    
    if is_directory:
        print(f"\n{Colors.CYAN}ðŸ“ Directory detected - using ZIP compression for reliable transfer{Colors.ENDC}")
        compress = True
        compress_format = "zip"
    else:
        print(f"\n{Colors.CYAN}ðŸ“„ File detected - using direct SCP transfer{Colors.ENDC}")
        compress = False
    
    # Smart destination handling
    print_info("Determining optimal destination path...")
    smart_dest = smart_destination_path(source_path, user, host, port, password, compress, compress_format)
    
    dest_path = input(f"{Colors.BOLD}Destination path [{smart_dest}]: {Colors.ENDC}").strip()
    if not dest_path:
        dest_path = smart_dest
    else:
        # User provided custom path, still check for conflicts
        dest_path = resolve_destination_conflict(user, host, port, password, dest_path, source_path_obj.name)
    
    # Handle compression
    temp_archive = None
    if compress:
        print_info(f"Compressing directory to {compress_format.upper()}...")
        
        try:
            if compress_format == "zip":
                import zipfile
                temp_archive = f"/tmp/{source_path_obj.name}_{os.getpid()}.zip"
                
                with zipfile.ZipFile(temp_archive, 'w', zipfile.ZIP_DEFLATED) as zipf:
                    for root, dirs, files in os.walk(source_path):
                        # Skip problematic directories
                        dirs[:] = [d for d in dirs if not d.startswith('.') or d == '.ipynb_checkpoints']
                        
                        for file in files:
                            file_path = os.path.join(root, file)
                            arc_path = os.path.relpath(file_path, os.path.dirname(source_path))
                            try:
                                zipf.write(file_path, arc_path)
                            except (OSError, ValueError) as e:
                                print_warning(f"Skipping problematic file: {file_path} ({e})")
                
            else:  # tar.gz
                import tarfile
                temp_archive = f"/tmp/{source_path_obj.name}_{os.getpid()}.tar.gz"
                
                with tarfile.open(temp_archive, 'w:gz') as tar:
                    tar.add(source_path, arcname=source_path_obj.name, 
                           filter=lambda tarinfo: None if '.ipynb_checkpoints' in tarinfo.name and tarinfo.name.count('.ipynb_checkpoints') > 1 else tarinfo)
            
            source_to_transfer = temp_archive
            print_success(f"Compression completed: {temp_archive}")
            
        except Exception as e:
            print_error(f"Compression failed: {e}")
            return False
    else:
        source_to_transfer = source_path
    
    print_info(f"Transferring {'compressed archive' if compress else ('directory' if is_directory else 'file')}: {os.path.basename(source_to_transfer)}")
    print_info(f"To: {user}@{host}:{dest_path}")
    
    # Build SCP command
    try:
        # All transfers are now either files (direct) or compressed archives
        cmd = ['sshpass', '-p', password, 'scp', '-o', 'StrictHostKeyChecking=no',
               '-P', port, source_to_transfer, f'{user}@{host}:{dest_path}']
        
        print_info("Starting transfer...")
        result = subprocess.run(cmd, text=True)
        
        # Cleanup temp archive
        if temp_archive and os.path.exists(temp_archive):
            os.remove(temp_archive)
            print_info("Temporary archive cleaned up")
        
        if result.returncode == 0:
            print_success("Transfer completed successfully!")
            
            # Provide extraction instructions
            if compress:
                # Install unzip first
                print_info("Installing unzip on destination server...")
                unzip_installed = install_remote_dependencies(user, host, port, password)
                
                print_info("To extract on the destination server:")
                if compress_format == "zip":
                    print(f"  {Colors.BOLD}unzip '{dest_path}'{Colors.ENDC}")
                else:
                    print(f"  {Colors.BOLD}tar -xzf '{dest_path}'{Colors.ENDC}")
                    
                # Offer to auto-extract only if unzip was installed successfully
                if unzip_installed or compress_format == "tar.gz":
                    auto_extract = input(f"\n{Colors.YELLOW}Auto-extract on destination server? (y/N): {Colors.ENDC}").strip().lower()
                    if auto_extract == 'y':
                        return auto_extract_remote(user, host, port, password, dest_path, compress_format)
                else:
                    print_warning("Unzip installation failed. Please extract manually using the command above.")
            
            return True
        else:
            print_error("Transfer failed!")
            return False
            
    except FileNotFoundError:
        print_error("sshpass not found. Falling back to manual SCP command.")
        print_info("Please run the following command manually:")
        
        manual_cmd = f"scp -P {port} '{source_to_transfer}' {user}@{host}:{dest_path}"
        print(f"{Colors.BOLD}{manual_cmd}{Colors.ENDC}")
        
        # Cleanup temp archive
        if temp_archive and os.path.exists(temp_archive):
            os.remove(temp_archive)
        
        return False
    except Exception as e:
        print_error(f"Transfer error: {e}")
        
        # Cleanup temp archive
        if temp_archive and os.path.exists(temp_archive):
            os.remove(temp_archive)
        
        return False

def auto_extract_remote(user, host, port, password, archive_path, compress_format):
    """Automatically extract archive on remote server"""
    print_info("Extracting archive on remote server...")
    
    try:
        if compress_format == "zip":
            extract_cmd = f"cd $(dirname '{archive_path}') && unzip -o '{archive_path}' && rm '{archive_path}'"
        else:
            extract_cmd = f"cd $(dirname '{archive_path}') && tar -xzf '{archive_path}' && rm '{archive_path}'"
        
        cmd = ['sshpass', '-p', password, 'ssh', '-o', 'StrictHostKeyChecking=no',
               f'{user}@{host}', '-p', port, extract_cmd]
        
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        if result.returncode == 0:
            print_success("Archive extracted and cleaned up on remote server!")
            return True
        else:
            print_error(f"Extraction failed: {result.stderr}")
            print_info("You can extract manually using the commands shown above.")
            return False
            
    except Exception as e:
        print_error(f"Auto-extraction error: {e}")
        return False

def install_remote_dependencies(user, host, port, password):
    """Install unzip and other dependencies on remote server"""
    print_info("Installing extraction tools on remote server...")
    
    try:
        # Install unzip and tar
        install_cmd = "apt-get update -qq && apt-get install -y unzip"
        
        cmd = ['sshpass', '-p', password, 'ssh', '-o', 'StrictHostKeyChecking=no',
               f'{user}@{host}', '-p', port, install_cmd]
        
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
        
        if result.returncode == 0:
            print_success("Remote dependencies installed successfully!")
            return True
        else:
            print_warning(f"Could not install dependencies: {result.stderr}")
            return False
            
    except Exception as e:
        print_warning(f"Failed to install remote dependencies: {e}")
        return False

def generate_unique_filename(base_path):
    """Generate a unique filename by appending timestamp and random ID"""
    import time
    import random
    
    timestamp = int(time.time())
    random_id = random.randint(1000, 9999)
    
    path_obj = Path(base_path)
    if path_obj.suffix:
        # Has extension (file)
        stem = path_obj.stem
        suffix = path_obj.suffix
        parent = path_obj.parent
        unique_name = f"{stem}_{timestamp}_{random_id}{suffix}"
    else:
        # No extension (directory)
        parent = path_obj.parent
        unique_name = f"{path_obj.name}_{timestamp}_{random_id}"
    
    return str(parent / unique_name)

def check_remote_path_exists(user, host, port, password, remote_path):
    """Check if a path exists on remote server"""
    try:
        check_cmd = f"test -e '{remote_path}' && echo 'EXISTS' || echo 'NOT_EXISTS'"
        
        cmd = ['sshpass', '-p', password, 'ssh', '-o', 'StrictHostKeyChecking=no',
               f'{user}@{host}', '-p', port, check_cmd]
        
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
        
        if result.returncode == 0:
            return result.stdout.strip() == 'EXISTS'
        else:
            return False
            
    except Exception:
        return False

def resolve_destination_conflict(user, host, port, password, dest_path, source_name):
    """Resolve destination conflicts by checking remote and auto-renaming"""
    original_dest = dest_path
    
    # Check if destination exists
    if check_remote_path_exists(user, host, port, password, dest_path):
        print_warning(f"Destination '{dest_path}' already exists on remote server!")
        
        # Generate unique destination
        if dest_path.endswith('/'):
            # Directory destination, append unique name
            new_dest = dest_path + generate_unique_filename(source_name).split('/')[-1]
        else:
            # File destination, make it unique
            new_dest = generate_unique_filename(dest_path)
        
        print_success(f"Auto-resolved to unique destination: {new_dest}")
        return new_dest
    
    return dest_path

def smart_destination_path(source_path, user, host, port, password, compress=False, compress_format="zip"):
    """Intelligently determine the best destination path"""
    source_path_obj = Path(source_path)
    source_abs = os.path.abspath(source_path)
    
    # Determine base destination
    if compress:
        archive_name = f"{source_path_obj.name}.{compress_format}"
        base_dest = f"/workspace/{archive_name}"
    else:
        base_dest = f"/workspace/{source_path_obj.name}"
    
    # Check for recursion (copying directory into itself)
    if not compress and source_path_obj.is_dir():
        # Check if we're trying to copy a directory into itself
        dest_parent = "/workspace"
        if source_abs == dest_parent or source_abs.startswith(dest_parent + "/"):
            print_warning("Detected potential recursion - copying directory into itself!")
            
            # Auto-resolve by using a safe destination
            safe_name = f"{source_path_obj.name}_transfer_{int(__import__('time').time())}"
            base_dest = f"/tmp/{safe_name}"
            print_success(f"Auto-resolved to safe destination: {base_dest}")
    
    # Resolve any naming conflicts
    final_dest = resolve_destination_conflict(user, host, port, password, base_dest, source_path_obj.name)
    
    return final_dest
    """Automatically extract archive on remote server"""
    print_info("Extracting archive on remote server...")
    
    try:
        if compress_format == "zip":
            extract_cmd = f"cd $(dirname '{archive_path}') && unzip -o '{archive_path}' && rm '{archive_path}'"
        else:
            extract_cmd = f"cd $(dirname '{archive_path}') && tar -xzf '{archive_path}' && rm '{archive_path}'"
        
        cmd = ['sshpass', '-p', password, 'ssh', '-o', 'StrictHostKeyChecking=no',
               f'{user}@{host}', '-p', port, extract_cmd]
        
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        if result.returncode == 0:
            print_success("Archive extracted and cleaned up on remote server!")
            return True
        else:
            print_error(f"Extraction failed: {result.stderr}")
            print_info("You can extract manually using the commands shown above.")
            return False
            
    except Exception as e:
        print_error(f"Auto-extraction error: {e}")
        return False

def install_sshpass():
    """Install sshpass for password automation"""
    print_info("Installing sshpass for automated transfers...")
    try:
        subprocess.run(['apt', 'update'], check=True, capture_output=True)
        subprocess.run(['apt', 'install', '-y', 'sshpass'], check=True, capture_output=True)
        print_success("sshpass installed successfully!")
        return True
    except subprocess.CalledProcessError:
        print_warning("Could not install sshpass. Manual password entry will be required.")
        return False

def main():
    """Main function"""
    # Show version header
    print(f"{Colors.HEADER}{'='*60}{Colors.ENDC}")
    print(f"{Colors.HEADER}{SCRIPT_NAME} v{VERSION}{Colors.ENDC}".center(60))
    print(f"{Colors.HEADER}{'='*60}{Colors.ENDC}")
    
    print_header("RUNPOD FILE TRANSFER TOOL")
    print(f"{Colors.CYAN}Welcome! This tool helps you transfer files between RunPod instances.{Colors.ENDC}")
    print(f"{Colors.GREEN}Version: {VERSION} | Updated: 2025-08-12{Colors.ENDC}")
    
    # Check and install dependencies
    print_info("Checking dependencies...")
    
    if not check_ssh_installed():
        print_warning("SSH client not found.")
        if not install_ssh():
            print_error("Cannot proceed without SSH client.")
            sys.exit(1)
    
    if not check_scp_installed():
        print_error("SCP not found. Please install openssh-client.")
        sys.exit(1)
    
    # Check for sshpass
    try:
        subprocess.run(['sshpass', '-V'], capture_output=True, check=True)
    except (subprocess.CalledProcessError, FileNotFoundError):
        print_warning("sshpass not found. This tool provides password automation.")
        install_sshpass()
    
    print_success("All dependencies checked!")
    
    try:
        # Get connection details
        user, host, port, password = get_connection_details()
        
        # Test connection
        if not test_ssh_connection(user, host, port, password):
            print_error("Connection test failed. Please check your credentials and try again.")
            sys.exit(1)
        
        # Select file or folder
        selected_path = select_file_or_folder()
        if not selected_path:
            print_info("Transfer cancelled.")
            sys.exit(0)
        
        # Confirm transfer
        path_obj = Path(selected_path)
        item_type = "directory" if path_obj.is_dir() else "file"
        
        print(f"\n{Colors.BOLD}Transfer Summary:{Colors.ENDC}")
        print(f"  Source: {selected_path} ({item_type})")
        print(f"  Destination: {user}@{host}:{port}")
        
        confirm = input(f"\n{Colors.WARNING}Proceed with transfer? (y/N): {Colors.ENDC}").strip().lower()
        if confirm != 'y':
            print_info("Transfer cancelled.")
            sys.exit(0)
        
        # Perform transfer
        success = perform_transfer(selected_path, user, host, port, password)
        
        if success:
            print_success("File transfer completed successfully!")
        else:
            print_error("File transfer failed. Please check the manual command above.")
            
    except KeyboardInterrupt:
        print(f"\n\n{Colors.WARNING}Transfer cancelled by user.{Colors.ENDC}")
        sys.exit(0)
    except Exception as e:
        print_error(f"Unexpected error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
