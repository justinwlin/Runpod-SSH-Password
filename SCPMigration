#!/usr/bin/env python3
"""
RunPod File Transfer Tool
A CLI utility for transferring files between RunPod instances using rsync.
Author: Assistant
Last Updated: 2025-10-25
"""

import os
import sys
import subprocess
import re
from pathlib import Path

# Script version
VERSION = "2.0.0"
SCRIPT_NAME = "RunPod File Transfer Tool"

class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    WARNING = '\033[91m'  # Changed from yellow to red for better visibility
    YELLOW = '\033[91m'   # Changed from yellow to red for better visibility
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'

def print_header(text):
    print(f"\n{Colors.HEADER}{'='*50}{Colors.ENDC}")
    print(f"{Colors.HEADER}{text.center(50)}{Colors.ENDC}")
    print(f"{Colors.HEADER}{'='*50}{Colors.ENDC}")

def print_success(text):
    print(f"{Colors.GREEN}âœ“ {text}{Colors.ENDC}")

def print_error(text):
    print(f"{Colors.FAIL}âœ— {text}{Colors.ENDC}")

def print_warning(text):
    print(f"{Colors.WARNING}âš  {text}{Colors.ENDC}")

def print_info(text):
    print(f"{Colors.CYAN}â„¹ {text}{Colors.ENDC}")

def check_ssh_installed():
    """Check if SSH client is installed"""
    try:
        subprocess.run(['ssh', '-V'], capture_output=True, check=True)
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False

def check_rsync_installed():
    """Check if rsync is installed"""
    try:
        subprocess.run(['rsync', '--version'], capture_output=True, check=True)
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False

def install_ssh():
    """Install SSH client"""
    print_info("Installing SSH client...")
    try:
        # Try to install openssh-client
        subprocess.run(['apt', 'update'], check=True, capture_output=True)
        subprocess.run(['apt', 'install', '-y', 'openssh-client'], check=True, capture_output=True)
        print_success("SSH client installed successfully!")
        return True
    except subprocess.CalledProcessError:
        print_error("Failed to install SSH client. Please install manually.")
        return False

def install_rsync():
    """Install rsync"""
    print_info("Installing rsync...")
    try:
        subprocess.run(['apt', 'update'], check=True, capture_output=True)
        subprocess.run(['apt', 'install', '-y', 'rsync'], check=True, capture_output=True)
        print_success("rsync installed successfully!")
        return True
    except subprocess.CalledProcessError:
        print_error("Failed to install rsync. Please install manually.")
        return False

def parse_ssh_command(ssh_command):
    """Parse SSH command to extract host, port, and user"""
    # Pattern: ssh user@host -p port
    pattern = r'ssh\s+(\w+)@([\d\.]+)\s+-p\s+(\d+)'
    match = re.match(pattern, ssh_command.strip())
    
    if match:
        user, host, port = match.groups()
        return user, host, port
    else:
        print_error("Invalid SSH command format. Expected: ssh user@host -p port")
        return None, None, None

def list_files_and_folders(path="."):
    """List files and folders in the given path"""
    try:
        items = []
        path_obj = Path(path).resolve()
        
        # Add parent directory option if not at root
        if path_obj != path_obj.parent:
            items.append(("../", "ğŸ“ Parent Directory", True))
        
        # List directories first, then files
        for item in sorted(path_obj.iterdir(), key=lambda x: (x.is_file(), x.name.lower())):
            if item.is_dir():
                items.append((str(item), f"ğŸ“ {item.name}/", True))
            else:
                size = item.stat().st_size
                size_str = format_file_size(size)
                items.append((str(item), f"ğŸ“„ {item.name} ({size_str})", False))
        
        return items, str(path_obj)
    except PermissionError:
        print_error(f"Permission denied accessing {path}")
        return [], path
    except Exception as e:
        print_error(f"Error listing directory: {e}")
        return [], path

def format_file_size(size_bytes):
    """Format file size in human readable format"""
    if size_bytes == 0:
        return "0 B"
    
    units = ['B', 'KB', 'MB', 'GB', 'TB']
    unit_index = 0
    size = float(size_bytes)
    
    while size >= 1024 and unit_index < len(units) - 1:
        size /= 1024
        unit_index += 1
    
    if unit_index == 0:
        return f"{int(size)} {units[unit_index]}"
    else:
        return f"{size:.1f} {units[unit_index]}"

def select_file_or_folder():
    """Interactive file/folder selection with separate navigation and selection modes"""
    current_path = "/workspace" if os.path.exists("/workspace") else os.getcwd()
    
    while True:
        # NAVIGATION MODE
        while True:
            print_header("NAVIGATION MODE - Browse Files")
            items, current_path = list_files_and_folders(current_path)
            
            if not items:
                print_error("No items found in current directory")
                return None
            
            print(f"\n{Colors.BOLD}Current directory: {current_path}{Colors.ENDC}")
            print(f"\n{Colors.CYAN}Navigate by entering a number:{Colors.ENDC}")
            
            # Show items for navigation only
            for i, (path, display_name, is_dir) in enumerate(items, 1):
                if path == "../":
                    print(f"{Colors.BLUE}{i:2d}.{Colors.ENDC} {display_name}")
                elif is_dir:
                    print(f"{Colors.BLUE}{i:2d}.{Colors.ENDC} {display_name}")
                else:
                    print(f"{Colors.BLUE}{i:2d}.{Colors.ENDC} {display_name}")
            
            print(f"\n{Colors.GREEN}Ready to transfer something?{Colors.ENDC}")
            print(f"  {Colors.BOLD}s{Colors.ENDC} - Switch to SELECTION MODE")
            print(f"\n{Colors.WARNING}Other commands:{Colors.ENDC}")
            print(f"  {Colors.BOLD}h{Colors.ENDC} - Go to /workspace")
            print(f"  {Colors.BOLD}r{Colors.ENDC} - Go to root /")
            print(f"  {Colors.BOLD}q{Colors.ENDC} - Quit")
            
            try:
                choice = input(f"\n{Colors.BOLD}Navigate to (number/s/h/r/q): {Colors.ENDC}").strip().lower()
                
                if choice == 'q':
                    return None
                elif choice == 's':
                    break  # Exit navigation mode, enter selection mode
                elif choice == 'h':
                    current_path = "/workspace" if os.path.exists("/workspace") else os.path.expanduser("~")
                    continue
                elif choice == 'r':
                    current_path = "/"
                    continue
                
                # Try to parse as number for navigation
                try:
                    choice_idx = int(choice) - 1
                    if 0 <= choice_idx < len(items):
                        selected_path, display_name, is_dir = items[choice_idx]
                        
                        if selected_path == "../":
                            # Navigate to parent directory
                            current_path = str(Path(current_path).parent)
                            continue
                        elif is_dir:
                            # Navigate into directory
                            current_path = selected_path
                            continue
                        else:
                            # It's a file, suggest selection mode
                            print(f"\n{Colors.YELLOW}That's a file! Switch to selection mode (s) to transfer files.{Colors.ENDC}")
                            input("Press Enter to continue...")
                            continue
                    else:
                        print_error("Invalid choice. Please try again.")
                except ValueError:
                    print_error("Please enter a valid number or command (s/h/r/q).")
                    
            except KeyboardInterrupt:
                print("\n\nTransfer cancelled by user.")
                return None
        
        # SELECTION MODE
        while True:
            print_header("SELECTION MODE - Choose Files to Transfer")
            items, current_path = list_files_and_folders(current_path)
            
            if not items:
                print_error("No items found in current directory")
                return None
            
            print(f"\n{Colors.BOLD}Current directory: {current_path}{Colors.ENDC}")
            print(f"\n{Colors.GREEN}Select a file or folder to transfer:{Colors.ENDC}")
            
            # Show items for selection
            for i, (path, display_name, is_dir) in enumerate(items, 1):
                if path == "../":
                    print(f"{Colors.BLUE}{i:2d}.{Colors.ENDC} {display_name} {Colors.CYAN}[Navigate up]{Colors.ENDC}")
                elif is_dir:
                    print(f"{Colors.BLUE}{i:2d}.{Colors.ENDC} {display_name} {Colors.GREEN}[Select entire folder]{Colors.ENDC}")
                else:
                    print(f"{Colors.BLUE}{i:2d}.{Colors.ENDC} {display_name} {Colors.GREEN}[Select file]{Colors.ENDC}")
            
            print(f"\n{Colors.WARNING}Commands:{Colors.ENDC}")
            print(f"  {Colors.BOLD}n{Colors.ENDC} - Switch back to NAVIGATION MODE")
            print(f"  {Colors.BOLD}h{Colors.ENDC} - Go to /workspace")
            print(f"  {Colors.BOLD}r{Colors.ENDC} - Go to root /")
            print(f"  {Colors.BOLD}q{Colors.ENDC} - Quit")
            
            try:
                choice = input(f"\n{Colors.BOLD}Select item (number/n/h/r/q): {Colors.ENDC}").strip().lower()
                
                if choice == 'q':
                    return None
                elif choice == 'n':
                    break  # Exit selection mode, go back to navigation mode
                elif choice == 'h':
                    current_path = "/workspace" if os.path.exists("/workspace") else os.path.expanduser("~")
                    continue
                elif choice == 'r':
                    current_path = "/"
                    continue
                
                # Try to parse as number for selection
                try:
                    choice_idx = int(choice) - 1
                    if 0 <= choice_idx < len(items):
                        selected_path, display_name, is_dir = items[choice_idx]
                        
                        if selected_path == "../":
                            # Navigate to parent directory
                            current_path = str(Path(current_path).parent)
                            continue
                        else:
                            # File or folder selected for transfer - confirm
                            item_type = "folder" if is_dir else "file"
                            item_name = display_name.replace('ğŸ“ ', '').replace('ğŸ“„ ', '').split(' (')[0]
                            
                            print(f"\n{Colors.GREEN}Selected {item_type}: {Colors.BOLD}{item_name}{Colors.ENDC}")
                            print(f"Path: {selected_path}")
                            
                            confirm = input(f"\n{Colors.YELLOW}Transfer this {item_type}? (y/N): {Colors.ENDC}").strip().lower()
                            if confirm == 'y':
                                return selected_path
                            else:
                                print_info("Selection cancelled, continuing...")
                                continue
                    else:
                        print_error("Invalid choice. Please try again.")
                except ValueError:
                    print_error("Please enter a valid number or command (n/h/r/q).")
                    
            except KeyboardInterrupt:
                print("\n\nTransfer cancelled by user.")
                return None

def get_connection_details():
    """Get SSH connection details from user"""
    print_header("SSH CONNECTION DETAILS")
    
    print(f"{Colors.CYAN}Please provide the SSH connection details for the destination pod:{Colors.ENDC}")
    
    while True:
        ssh_command = input(f"\n{Colors.BOLD}Enter SSH command (e.g., ssh root@213.173.111.95 -p 17958): {Colors.ENDC}").strip()
        
        user, host, port = parse_ssh_command(ssh_command)
        if user and host and port:
            break
        print_error("Please enter a valid SSH command.")
    
    password = input(f"{Colors.BOLD}Enter password: {Colors.ENDC}").strip()
    
    return user, host, port, password

def test_ssh_connection(user, host, port, password):
    """Test SSH connection"""
    print_info("Testing SSH connection...")
    
    try:
        # Use sshpass if available, otherwise prompt user
        cmd = ['sshpass', '-p', password, 'ssh', '-o', 'StrictHostKeyChecking=no', 
               '-o', 'ConnectTimeout=10', f'{user}@{host}', '-p', port, 'echo "Connection successful"']
        
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=15)
        
        if result.returncode == 0:
            print_success("SSH connection test successful!")
            return True
        else:
            print_error(f"SSH connection failed: {result.stderr}")
            return False
            
    except FileNotFoundError:
        print_warning("sshpass not found. Please ensure you can connect manually.")
        return True  # Assume it will work
    except subprocess.TimeoutExpired:
        print_error("SSH connection timed out.")
        return False
    except Exception as e:
        print_error(f"Error testing connection: {e}")
        return False

def perform_transfer(source_path, user, host, port, password):
    """Perform the file transfer using rsync with compression"""
    print_header("FILE TRANSFER")

    source_path_obj = Path(source_path)
    is_directory = source_path_obj.is_dir()

    if is_directory:
        print(f"\n{Colors.CYAN}ğŸ“ Directory detected - using rsync with compression{Colors.ENDC}")
    else:
        print(f"\n{Colors.CYAN}ğŸ“„ File detected - using rsync transfer{Colors.ENDC}")

    # Smart destination handling
    print_info("Determining optimal destination path...")
    smart_dest = smart_destination_path_rsync(source_path, user, host, port, password)

    dest_path = input(f"{Colors.BOLD}Destination path [{smart_dest}]: {Colors.ENDC}").strip()
    if not dest_path:
        dest_path = smart_dest
    else:
        # User provided custom path, still check for conflicts
        dest_path = resolve_destination_conflict(user, host, port, password, dest_path, source_path_obj.name)

    print_info(f"Transferring {('directory' if is_directory else 'file')}: {source_path_obj.name}")
    print_info(f"To: {user}@{host}:{dest_path}")

    # Build rsync command
    try:
        # rsync with compression and progress
        # -r: recursive (for directories)
        # -l: copy symlinks as symlinks
        # -t: preserve modification times
        # -v: verbose
        # -z: compress during transfer
        # -P: show progress and keep partial transfers
        # --stats: show transfer statistics
        # --no-perms --no-owner --no-group: avoid permission errors on destination

        # Check if sshpass is available
        sshpass_available = True
        try:
            subprocess.run(['sshpass', '-V'], capture_output=True, check=True)
        except (subprocess.CalledProcessError, FileNotFoundError):
            sshpass_available = False

        if sshpass_available:
            rsync_cmd = [
                'sshpass', '-p', password,
                'rsync', '-rltvzP', '--stats',
                '--no-perms', '--no-owner', '--no-group',
                '-e', f'ssh -p {port} -o StrictHostKeyChecking=no',
                source_path if not is_directory else f'{source_path}/',
                f'{user}@{host}:{dest_path}'
            ]

            print_info("Starting rsync transfer with compression...")
            print_info("Progress will be displayed below:")
            print(f"{Colors.CYAN}{'='*60}{Colors.ENDC}")

            result = subprocess.run(rsync_cmd)

            print(f"{Colors.CYAN}{'='*60}{Colors.ENDC}")

            if result.returncode == 0:
                print_success("Transfer completed successfully!")
                return True
            else:
                print_warning(f"Transfer completed with warnings (exit code: {result.returncode})")
                print_info("This is often fine - the file was transferred but some attributes couldn't be set.")
                return True  # Consider it successful if files were transferred
        else:
            print_error("sshpass not found. Falling back to manual command.")
            print_info("Please run the following command manually:")

            manual_cmd = f"rsync -rltvzP --no-perms --no-owner --no-group -e 'ssh -p {port}' '{source_path}' {user}@{host}:{dest_path}"
            print(f"{Colors.BOLD}{manual_cmd}{Colors.ENDC}")

            print_info("\nAlternatively, install sshpass to automate the process:")
            print(f"{Colors.BOLD}apt-get update && apt-get install -y sshpass{Colors.ENDC}")

            return False

    except FileNotFoundError:
        print_error("rsync not found. Please install it first:")
        print(f"{Colors.BOLD}apt-get update && apt-get install -y rsync{Colors.ENDC}")
        return False
    except Exception as e:
        print_error(f"Transfer error: {e}")
        return False

def install_remote_rsync(user, host, port, password):
    """Install rsync on remote server if not present"""
    print_info("Checking for rsync on remote server...")

    try:
        check_cmd = "which rsync || (apt-get update -qq && apt-get install -y rsync)"

        cmd = ['sshpass', '-p', password, 'ssh', '-o', 'StrictHostKeyChecking=no',
               f'{user}@{host}', '-p', port, check_cmd]

        result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)

        if result.returncode == 0:
            print_success("rsync is available on remote server!")
            return True
        else:
            print_warning(f"Could not verify/install rsync: {result.stderr}")
            return False

    except Exception as e:
        print_warning(f"Failed to check remote rsync: {e}")
        return False

def generate_unique_filename(base_path):
    """Generate a unique filename by appending timestamp and random ID"""
    import time
    import random
    
    timestamp = int(time.time())
    random_id = random.randint(1000, 9999)
    
    path_obj = Path(base_path)
    if path_obj.suffix:
        # Has extension (file)
        stem = path_obj.stem
        suffix = path_obj.suffix
        parent = path_obj.parent
        unique_name = f"{stem}_{timestamp}_{random_id}{suffix}"
    else:
        # No extension (directory)
        parent = path_obj.parent
        unique_name = f"{path_obj.name}_{timestamp}_{random_id}"
    
    return str(parent / unique_name)

def check_remote_path_exists(user, host, port, password, remote_path):
    """Check if a path exists on remote server"""
    try:
        check_cmd = f"test -e '{remote_path}' && echo 'EXISTS' || echo 'NOT_EXISTS'"
        
        cmd = ['sshpass', '-p', password, 'ssh', '-o', 'StrictHostKeyChecking=no',
               f'{user}@{host}', '-p', port, check_cmd]
        
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
        
        if result.returncode == 0:
            return result.stdout.strip() == 'EXISTS'
        else:
            return False
            
    except Exception:
        return False

def resolve_destination_conflict(user, host, port, password, dest_path, source_name):
    """Resolve destination conflicts by checking remote and auto-renaming"""
    original_dest = dest_path
    
    # Check if destination exists
    if check_remote_path_exists(user, host, port, password, dest_path):
        print_warning(f"Destination '{dest_path}' already exists on remote server!")
        
        # Generate unique destination
        if dest_path.endswith('/'):
            # Directory destination, append unique name
            new_dest = dest_path + generate_unique_filename(source_name).split('/')[-1]
        else:
            # File destination, make it unique
            new_dest = generate_unique_filename(dest_path)
        
        print_success(f"Auto-resolved to unique destination: {new_dest}")
        return new_dest
    
    return dest_path

def smart_destination_path_rsync(source_path, user, host, port, password):
    """Intelligently determine the best destination path for rsync"""
    source_path_obj = Path(source_path)

    # Default to /workspace for Runpod
    base_dest = f"/workspace/"

    # For files, add filename; for directories, rsync handles it with trailing slash
    if source_path_obj.is_file():
        base_dest = f"/workspace/{source_path_obj.name}"

    # Resolve any naming conflicts
    final_dest = resolve_destination_conflict(user, host, port, password, base_dest, source_path_obj.name)

    return final_dest

def install_sshpass():
    """Install sshpass for password automation"""
    print_info("Installing sshpass for automated transfers...")
    try:
        subprocess.run(['apt', 'update'], check=True, capture_output=True)
        subprocess.run(['apt', 'install', '-y', 'sshpass'], check=True, capture_output=True)
        print_success("sshpass installed successfully!")
        return True
    except subprocess.CalledProcessError:
        print_warning("Could not install sshpass. Manual password entry will be required.")
        return False

def main():
    """Main function"""
    # Show version header
    print(f"{Colors.HEADER}{'='*60}{Colors.ENDC}")
    print(f"{Colors.HEADER}{SCRIPT_NAME} v{VERSION}{Colors.ENDC}".center(60))
    print(f"{Colors.HEADER}{'='*60}{Colors.ENDC}")
    
    print_header("RUNPOD FILE TRANSFER TOOL")
    print(f"{Colors.CYAN}Welcome! This tool helps you transfer files between RunPod instances.{Colors.ENDC}")
    print(f"{Colors.GREEN}Version: {VERSION} | Updated: 2025-08-12{Colors.ENDC}")
    
    # Check and install dependencies
    print_info("Checking dependencies...")

    if not check_ssh_installed():
        print_warning("SSH client not found.")
        if not install_ssh():
            print_error("Cannot proceed without SSH client.")
            sys.exit(1)

    if not check_rsync_installed():
        print_warning("rsync not found.")
        if not install_rsync():
            print_error("Cannot proceed without rsync.")
            sys.exit(1)

    # Check for sshpass
    try:
        subprocess.run(['sshpass', '-V'], capture_output=True, check=True)
    except (subprocess.CalledProcessError, FileNotFoundError):
        print_warning("sshpass not found. This tool provides password automation.")
        install_sshpass()

    print_success("All dependencies checked!")
    
    try:
        # Get connection details
        user, host, port, password = get_connection_details()

        # Test connection
        if not test_ssh_connection(user, host, port, password):
            print_error("Connection test failed. Please check your credentials and try again.")
            sys.exit(1)

        # Ensure rsync is installed on remote server
        install_remote_rsync(user, host, port, password)
        
        # Select file or folder
        selected_path = select_file_or_folder()
        if not selected_path:
            print_info("Transfer cancelled.")
            sys.exit(0)
        
        # Confirm transfer
        path_obj = Path(selected_path)
        item_type = "directory" if path_obj.is_dir() else "file"
        
        print(f"\n{Colors.BOLD}Transfer Summary:{Colors.ENDC}")
        print(f"  Source: {selected_path} ({item_type})")
        print(f"  Destination: {user}@{host}:{port}")
        
        confirm = input(f"\n{Colors.WARNING}Proceed with transfer? (y/N): {Colors.ENDC}").strip().lower()
        if confirm != 'y':
            print_info("Transfer cancelled.")
            sys.exit(0)
        
        # Perform transfer
        success = perform_transfer(selected_path, user, host, port, password)
        
        if success:
            print_success("File transfer completed successfully!")
        else:
            print_error("File transfer failed. Please check the manual command above.")
            
    except KeyboardInterrupt:
        print(f"\n\n{Colors.WARNING}Transfer cancelled by user.{Colors.ENDC}")
        sys.exit(0)
    except Exception as e:
        print_error(f"Unexpected error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
